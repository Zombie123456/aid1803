day27 2018.5.9
吕泽  lvze@tedu.cn   

1.网络-->进程线程-->web服务器-->mongo-->regex-->项目
2.编程原则:
  高类聚:功能尽量单一
  低耦合:相互独立性高
3.网 络体系结构标准OSI模型:
  应用层:提供用户服务
  表示层:提供数据压缩解压和加密
  会话层:建立程序级连接,决定用什么传输服务
  传输层:提供合适的通信服务,流量控制
  网络层:路由选择,网络互联,分组传输
  链路层:提供链路交换,具体消息发送
  物理层:物理硬件,接口
  优点:将功能分开,降低网络传输的耦合度,
        每一部分完成自己的功能,结构清晰
  四层或五层模型应用更广泛
  四层:应用层(应用,表示,会话),传输层,网络层,物理链路层
  TCP/IP五层模型:
  应用层(应用,表示,会话),传输层,网络层,链路层,物理层
4.协议:网络协议:
  即在网络传输过程中为保证通信正常而制定的大家都遵守的约定 
  1.应用层协议:TFTP,DNS,FTP,SMTP,HTTP
  2.传输层   :TCP,UDP
  3.网络层   :IP,ARP,ICMP 
  4.物理链路层:IEEE 
5.socket模块
  gethostname() -- return the current hostname
  gethostbyname() -- map a hostname to its IP number
  gethostbyaddr() -- map an IP number or hostname to DNS info
  inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
  inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
  getservname("程序名"):返回端口号
6.IP:
  IPV4:点分十进制
  127.0.0.1:本地测试IP
  0.0.0.0:局域网可用IP
  x.x.x.0:网段
  x.x.x.1:网关
  x.x.x.255:广播地址
7.端口号:
  地址的组成部分,区分应用层程序
  1-65535:1-255:众所周知的端口,256-1023:系统端口
8.子网掩码:和IP配合过滤网段 DNS:域名解析
9.字节序:`
  大端序:高字节存在低地址
  小端序:低字节存在高地址
  网络字节序:将字节序发送接受方式统一
10.传输层服务:
  1.tcp协议-面向连接的可靠的数据传输:
    1.特点:
      数据的可靠性:无重复 无丢失 无失序 无错误
      传输服务必须建立连接,传输数据必须保证可靠,
      传输结束必须断开连接
    2.使用情况:
      对传输质量要求较高,需要可靠的传输.
      传输的数据量较大（比如传文件）不需要频繁的连接断开
    3.三次握手:
      1.客户端向服务端发送连接请求(发送一个试探性的标志字符给服务器）
        SYN=1,Sep=x
      2.服务器端接受到请求后告知客户端可以连接
        SYN=1,ACK=x+1,Sep=y
      3.再次告知服务器客户端已经收到回复，下面要开始发送具体消息
        ACK=y+1,Sep=z
    4.四次挥手:
      1.主动方发送报文告知被动方要断开连接
        fin=1,Ack=z,Sep=x
      2.被动方返回报文告知主动方已经接受到你的请求
        Ack=x+1,Seq=z
      3.被动方会再次发送报文表示已经准备就绪可以断开
        fin=1,Ack=x,Sep=y
      4.主动方断开连接告知被动方
        Ack=y,sep=x
  2.udp协议-面向无连接的不可靠服务
    1.特点:
      不保证数据的完整性
      数据的发送都是由发起端决定的，不考虑接收端的情况
      没有三次握手和四次回收的过程
      对实时性要求较高
    2.使用情况:
      网络情况不佳的时候
      对数据的准确性没有严格要求
      建立必要的非连接的情况(比如广播组播)
11.套接字编程:
  1.套接字(socket):进行网络通信的一种手段
  2.套接字的分类
    1.流式套接字(SOCK_STREAM):
      传输层使用tcp协议提供面向连接的传输服务 
    2.数据报套接字(SOCK_DGRAM):
      传输层使用udp协议提供面向无连接的传输服务 
    3.原始套接字(SOCK_RAW):
      一般用作底层协议测试(用不到)
  3.TCP服务端操作步骤:
    from socket import *
    1.创建套接字
      s = socket(socket_family=AF_INET,
             socket_type=SOCK_STREAM,proto=0)
      功能:创建套接字
      参数:选择地址族种类,套接字类型,子协议类型
      返回值:返回创建的套接字
    2.绑定IP和端口号
      s.bind(address)
      功能:绑定本机的IP和端口号
      参数:是一个包含两个元素的元组,
          第一个元素是字符串形式的IP，第二个是使用的端口号
    3.让套接字有监听功能
      s.listen(n)
      功能:将套接字设置为监听套接字,并且设置一个监听队列
      参数:是一个正整数,监听队列大小
    4.等待客户端连接
      conn, addr = s.accept()
      功能:阻塞等待客户端的连接 
      参数:无
      返回值:第一个返回值:新的套接字用来和客户端通信
          第二个返回值:连接进来的客户端的address
    5.消息的收发
      1.conn.recv(buffer)
        功能:接收网络消息
        参数:正整数 表示一次接收从缓冲区中拿到的消息的字节数
        返回值:返回接收到的消息
        * 当接受的网络缓冲中没有内容时会阻塞
        * 当连接断开后，recv会结束阻塞返回一个空字串
      2.conn.send(data)
        功能:发送网络消息
        参数:要发送的内容  
        返回值:实际发送的字节数
        *python3中要求send的内容必须为bytes格式
        无接受端时,会引发brokenpipe异常
      3.conn.sendall(data)
        功能:发送网络消息
        参数:要发送的内容要求为bytes格式
        返回值:如果成功发送返回None发送失败报异常
    6.关闭套接字
      conn.close() 
      s.close()
      功能:关闭一个套接字
  4.tcp客户端流程:
    1.创建流式套接字
    2.发起连接请求:
      connect()
      功能:发起连接
      参数:一个元组,1.服务器IP 2.服务器port
    3.收发信息
    4.关闭套接字
day28 2018.5.10

1.tcp 数据传输
  1.发送和接受消息都会先放到缓冲区再处理
  2.recv如果一次没有拿完，那么下次会继续收取没拿完的消息.
  3.当recv阻塞时,如果客户端断开,则recv立即返回空字符串
2.tcp 粘包
  1.粘包是tcp传输特有的现象，因为tcp中数据以数据流的方式传输没有消息边界。如果是发送连续的内容比如文件等则粘包没有影响。如果是每次发送为单独需要处理内容则需要处理粘包
  2.如何处理粘包
    1.每次发送消息结束位置加标志
    2.发送的消息添加结构描述
    3.让消息的发送延迟，使接收端每次都能够有时间接受一个消息
3.UDP 数据报套接字服务器
  1.创建数据报套接字
    sockfd = socket(AF_INET, SOCK_DGRAM)
  2.绑定本地IP和端口
    sockfd.bind(addr)
  3.收发消息
    data, addr = sockfd.recvfrom(BUFFERSIZE)
    功能 :在udp中接受消息
    参数 :buffersize 表示一次最多可以接收多少字节的消息
    返回值:data:接收到的消息
          addr:表示从哪个客户端接收到的消息
    sockfd.sendto(data,addr)
    功能:向一个网络终端发送消息
    参数:data 要发送的消息（bytes）
        addr 发送对象的地址
  4.关闭套接字
    sockfd.close()
  import sys  
  sys.argv:将命令行内容收集为一个列表，每个元素是命令行中的一项
  * 命令行传入的内容均为str格式
  * 命令行内容以空格作为分割， 引号可以合成一个整体
4.udp 客户端
  1.创建数据报套接字
  2.消息收发
  3.关闭套接字
  4.recvfrom每次之能接受一个数据包，如果数据包的大小超过recvfrom的设置大小则会出现数据丢失
5.总结 tcp和udp的区别
  1.tcp是有连接的，udp是无连接的
  2.tcp有三次握手四次挥手的过程，udp没有
  3.tcp是以数据流传输数据，会有粘包，udp是数据报的形式没有占粘包
  4.tcp的连接需要消耗一定的资源，相比之下udp资源消耗少
  5.tcp保证数据的可靠性，udp不保证
  6.tcp需要listen  accept  connect ，udp不需要这些操作
  7.消息收发tcp:recv,send,sendall udp:recvfrom,sendto
6.socket模块
  1.sockfd.type套接字类型
  2.conn.getpeername()
    功能:使用accept生成的套接字调用,获取该套接字对应的客户端地址
  3.sockfd.getsockname()
    功能:获取套接字对应的绑定的地址
  4.sockfd.fileno() 
    功能:获取套接字的文件描述符号码
    文件描述符:系统会给进程中的每一个IO操作对象非配一个>=0的正整数作为标号，我们称之为该IO操作的文件描述符。一个进程中所有IO的文件描述符不会重复
  5.sockfd.setsockopt(level，optname，value)
    功能:设置套接字选项  可以增加或改变套接字的功能
    参数:level要定义的选项类型:SOL_SOCKET
        optname根据level确定的子选项
        value根据选项设置的值
    示例:s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
          可以立即对使用的端口重新使用
  6.s.getsockopt(level，optname)
    功能：获取相应选项的值
    参数:level  要获取的选项类型         
       optname  每种类型都有具体的选项 根据具体需求选择要获取的选项
   返回值：获取到的值
7.udp应用之广播 (是一端发送，多端接收的模式)
  设置套接字为可以发送接收广播的套接字
  sockfd.setsockopt(SOL_SOCKET,SO_BROADCAST,1)
  udp 数据报套接字
  广播地址 : 172.60.50.255 
  *在网络中如果存在大量的广播会产生广播风暴，占用大量带宽
8.tcp应用之http传输
  1.http协议(超文本传输协议)
    1.网站中网页的传输和数据的传输,也用于基于http协议的编程传输数据
    2.应用层协议,传输层使用TCP连接,简单,灵活,接口使用方便,几乎支持所有的数据类型,无状态的(不记录客户端的登录状态),http1.1版本后持续连接
    3.请求(request)
      1.格式:
        请求行:确定具体的请求类型
        请求头:对请求内容的信息描述
        空行
        请求正文:具体请求参数
      2.请求行:GET    /index.html HTTP/1.1
              请求方法  请求资源     协议版本
        1.请求方法:
          1.GET:获取网络资源
          2.POST:提交一定的附加数据,得到返回结果
          3.HEAD:只获取响应头信息
          4.PUT:获取服务器资源
          5.DELETE:删除服务器资源
          6.TRACE:用于测试
          7.CONNECT:保留方法
          8.OPTIONS:请求获取服务器性能和信息
      3.请求头
      4.请求正文
        1.GET:get参数 &a=1&b=2
        2.POST:post提交的内容
    4.响应(response)
      1.格式:
        响应行:反馈响应的情况
        响应头:对响应的具体描述
        空行
        响应体:具体返回给用户的内容
      2.响应行
        1.格式:http/1.1 200  OK
              协议版本  响应码 信息
          1.响应码
            1xx:提示信息,请求已接受正在处理
            2xx:请求响应成功
            3xx:重定向,完成任务需要其他操作
            4xx:请求资源不存在,客户端错误
            5xx:服务端错误
            200:成功
            401:没有访问权限
            404:资源不存在
            500:服务器发生未知错误
            503:服务器暂时无法执行
      3.响应头
        格式同请求头
      4.响应体
        文件,图片...
  2.网站访问流程  
    1.客户端发起http请求
    2.传输层使用TCP协议建立连接,层层打包将请求内容发给服务器
    3.web服务器接包后解析http请求,交后端应用程序处理
    4.后端应用得到结果,通过web服务器回发给客户端
day29 2018.5.11
1.tcp应用之http服务器
  1.接受http请求
  2.给出响应
2.IO 
  1.在内存中存在数据交换的操作
    1.内存和磁盘交换
    2.内存和网络交换
  2.IO密集型程序
  3.CPU密集型程序
  4.分类:
    1.阻塞IO:
      1.所有IO操作默认就是阻塞的
      2.阻塞:等待某种条件达成再继续运行
            处理IO事件时耗时较长
      3.效率最低
    2.非阻塞IO:
      1.通过修改IO对象让他变为非阻塞状态
      2.用循环不断判断阻塞条件,需要消耗更多CPU但是一定程度上提高了IO效率
      3.sockfd.setblocking(False)
      4.超时等待(检测)
        sockfd.settimeout(sec)
        对原本阻塞的函数进行设置,使其不再始终阻塞,而是阻塞等待一定时间后自动返回.在规定时间中如果正常结束阻塞则继续执行,否则产生timeout异常
    3.IO多路复用
      1.同时监控多个IO事件,当哪个IO事件准备就绪就执行哪个IO事件,形成并发效果
      2.import select
        1.select
          r,w,x = select(rlist,wlist,xlist[,timeout])
            功能:监控IO事件,阻塞等待IO事件发生
            参数:list列表,存放要监控等待处理的IO
              wlist列表:存放我们希望处理的IO
              xlist列表:存放如果发生异常需要处理的
              timeout数字:超时检测
            返回值:r列表:rlist中准备就绪的IO
              w列表:wlist中准备就绪的IO
              x列表:xlist中准备就绪的IO
        2.poll
          1.创建poll对象
            p = select.poll()
          2.加入关注的IO
            p.register(s)
            p.unregister(s)
          3.使用poll函数进行监控
            events = p.poll()
            阻塞等待register的事件,只要有任意一个准备就绪就返回
            events是个列表[(fileno,event),(),()]
          4.处理发生的IO事件
          5.poll IO 事件
            1.POLLIN
              rlist
            2.POLLOUT
              wlist
            3.POLLUP
              断开连接
            4.POLLERR
              xlist
            5.POLLPRI
              紧急处理
            6.POLLVAL
              无效的数据 
        3.epoll
          1.几乎与poll一致
          2.效率比select和poll高,不支持WINDOWS,支持水平和边缘(EPOLLET)触发,
          select和poll只支持水平触发
      3.注意:
        1.处理IO过程中不能出现死循环
        2.是单进程程序,是一个并发程序
        3.有较高的IO执行效率
    4.事件驱动IO
    5.异步IO 
3.traceback模块
  traceback.print_xec()
    打印异常信息
4.本地套接字
  1.linux文件类型
    b(块设备文件)c(字符设备文件)d(文件夹)-(普通文件)
    l(链接文件)s(套接字文件)p(管道文件)
  2.意义:
    linux或Unix操作系统下提供本地进程间通信的一种方式
  3.本地套接字创建流程
    1.创建套接字文件
    2.绑定套接字文件
    3.监听
    4.接受连接
    5.消息收发
day30 2018.5.14

1.os模块
  1.os.unlink() or os.remove()
    删除某个文件
    参数:一个路径文件
  2.os.path.exists()
    判断一个文件是否存在
    参数:一个路径文件
2.多任务编程
  1.通过应用程序利用多个计算机核心达到多任务同时执行的目的,以此来提升程序执行效率
  2.多进程,多线程
    1.进程
      1.程序在计算机中一次执行的过程
      2.是一个动态的过程,占有CPU内存的计算机资源,有一定的生命周期
    2.程序:
      1.是一个静态的描述,不占有计算机资源
      2.同一个程序,每次执行都是不同的进程.因为分配的计算机资源不同
  3.进程的创建流程
    1.用户空间运行程序发起进程创建申请
    2.调用操作系统内核借口创建进程
    3.分配计算机资源,确定进程状态
    4.将新的进程提供给用户使用
  4.多个进程如何占用CPU
    1.一个内核同一时刻只能运行同一任务
    2.多个进程对内核资源进行争夺,操作系统决定
    3.占有计算机核心的进程我们称该进程占有CPU的时间片
  5.进程有哪些信息,如何保存
    1.pcb(进程控制块):
      在linux和UNIX系统中进程创建后,会在内存开辟一块空间,存放进程的相关信息,称为pcb
      查看进程信息 ps -aux
      1.信息:用户 PID 占有内存 优先级
        1.PID:在操作系统中,进程的唯一标识,是大于0的整数,有系统自动分配
  6.进程特征
    1.进程是操作系统资源分配的最小单位
    2.每个进程单独占有4G的虚拟内存空间
    3.进程之间相互独立,运行不受影响
  7.进程的状态
    1.三态
      1.就绪态
        进程具备运行条件,等待系统分配处理器运行
      2.运行(执行)态
        进程占有CPU处于运行的状态
      3.等待(阻塞,睡眠)态
        进程暂时不具备运行的条件,需要阻塞等待
    2.五态 
      1.新建
        创建一个进程获取资源,运行一个程序或在程序中创建新的进程
      2.就绪
      3.执行
      4.等待/阻塞
      5.终止
        进程执行结束,资源回收过程
    3.ps -aux -->STAT表示进程状态
      1.D:等待态(不可中断等待)
      2.S:等待态(可中断等待)
      3.T:等待态(暂停)
      4.R:运行态
      5.Z:僵尸态
      6.+:前台进程 (无+表示后台进程)
      7.<:高优先级
      8.N:低优先级
      9.l:有进程链接
      10.s:会话组
  8.进程优先级
    1.优先级决定一个进程的执行权限和占有资源的优先程度
    2.ps -ajx
    3.top
      1.动态查看当前运行的进程状态
      2.< >翻页 NI表示优先级
    4.优先级范围
      1.-20~19 -20最高
      2.用户程序优先级默认为0
    5.nice
      1.以指定的优先级运行程序
      2.示例:
        1.以9的优先级运行
          nice -9
        2.以-9的优先级运行
          sudo nice --9
    6.renice 
      1.改变某个进程的优先级
      2.示例
        1.改为2优先级运行
          sudo renice 2 PID号
  9.父子进程
    1.在系统中除了初始化进程,其他进程都有一个父进程,可能有多个子进程
    2.进程树pstree命令
3.os.fork()
  1.功能:创建一个新进程
  2.参数:无
  3.返回值
    1.失败返回一个负数
    2.成功
      1.返回0
        在子进程中fork的返回值
      2.正整数(子进程的PID)
        在父进程中的返回值
  4.父进程中fork之前的内容子进程同样会复制,但父子进程空间独立,fork后的修改不会影响对方
  5.父子进程在执行上互不影响,谁先执行不确定
  6.子进程虽然复制父进程的空间,但是有自己的特性,比如自己的PID,进程PCB,进程栈空间等
4.进程相关函数
  1.os.getpid()
    1.功能:获取当前进程的PID号
    2.返回值:当前进程的PID号
  2.os.getppid()
    1.功能:获取当前进程父进程的PID号
    2.返回值:当前进程父进程的PID号
  3.os._exit(status)
    1.功能:结束一个进程
    2.参数:
      1.表示进程的结束状态,是一个整数
      2.惯例传入0表示正常退出,非0表示不正常退出
  4.sys.exit([status])
    1.功能:抛出异常SystemExit,结束一个进程
    2.参数:
      1.传入一个正整数表示结束状态
      2.传入字符串,表示结束,打印字符串
5.孤儿进程 
  1.父进程先于子进程退出,此时子进程变为孤儿进程
  2.孤儿进程会被系统指定的进程'收养',该进程成为孤儿进程新的父进程
  3.在孤儿进程退出时,继父会进行处理,不会使其变为僵尸进程
6.僵尸(zombie)进程
  1.子进程先退出,但是父进程没处理子进程的退出状况,子进程就会变为僵尸进程
  2.僵尸进程会滞留PCB的部分信息在内存中,大量的僵尸进程会消耗系统资源,应避免僵尸进程的产生 
  3.避免产生
    1.父进程先退(不好控制)
    2.让父进程处理子进程的退出
      1.使用wait或waitpid函数
        1.os.wait()
          1.功能:等待子进程的退出进行处理
          2.返回值:
            1.一个二元元组
            2.第一个值为退出的子进程PID
            3.第二个值为进程退出状态为sys.exit(status)的status*5
        2.os.waitpid()
          1.功能:处理子进程的退出
          2.参数:
            1.pid:
              1.-1:表示等待任意的子进程退出
              2.>0:表示等待相应的PID号的子进程
            2.option:
              1.0:表示阻塞等待
              2.os.WNOHANG:表示非阻塞等待
          3.返回值:
            1.一个二元元组
            2.第一个值为退出的子进程PID
            3.第二个值为进程退出状态为sys.exit(status)的status*5
          4.示例:
            见waitpid.py
    3.使用信号处理
    4.创建二级子进程
      1.整体思路
        1.父进程创建子进程后等待子进程退出
        2.子进程创建二级子进程后马上退出,二级子进程成为孤儿
        3.让父进程和二级子进程处理事件
      2.示例:
        见fork.py
day31 2018.5.15

1.multiprocessing模块
  1.需要将事件封装成函数
  2.使用multiprocessing提供的类创建新进程
    1.创建子进程类
      1.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
        1.功能:创建子进程
        2.参数:
          1.name:给创建的进程起个名字 默认process-1
          2.target:目标函数
          3.args:元组 要给函数传递的参数 位置传参
          4.kwargs:字典 要给函数传递的参数 键值传参
        3.p = multiprocessing.Process(target=th1)
          1.p.start()
            启动子进程
          2.p.join([timeout])
            阻塞等待回收相应的子进程
          3.p.name
            进程名称
          4.p.pid
            创建的进程的PID号
          5.p.is_alive()
            进程状态 返回True or False
          6.p.daemon = True
            1.父进程结束时子进程全部结束
            2.不用写join不会产生僵尸进程
            3.设置必须在p.start()前
            4.不是linux/UNIX中所说的守护进程
              1.守护进程
                1.生命周期长,随系统创建时创建
                2.不受前端控制,后台运行
                3.操作系统进程,或是自动化运行进程居多
  3.新的进程和对应的函数相关联,进程启动自动执行函数完成事件
  4.进程回收
day32 2018.5.16

1.创建自己的进程类
  1.继承Process类以获取原有的属性
  2.实现自己需要的功能部分
  3.使用自己的类创建进程即可
2.多进程
  1.优点
    1.并行多个任务,提高运行效率
    2.空间独立,数据安全,创建方便
  2.缺点
    进程创建的过程中消耗较多的计算机资源
  3.在需要频繁的创建和删除较多进程的情况下，资源消耗过多，不适宜使用多进程完成任务
3.进程池
  from multiprocessing import pool
  1.创建进程池,在池内放入合适数量的进程
    1.Pool()
      1.功能:创建进程池
      2.参数:processes:进程池中进程的数量
      3.返回:得到进程池对象
  2.将事件加入进程池的等待队列
    1.pool.apply_async() 
      1.功能:以异步的方式将要执行的事件放入进程池
      2.参数:
        1.func:要执行的函数
        2.args:给函数按位置传参 元组
        3.kwds:给函数按照键值传参 字典
      3.返回值:
        返回事件执行后的返回值对象,可以通过调用get()函数获取事件函数return的内容
    2.pool.map(func, iterable)
      1.功能:
        类似于内建函数map将第二个参数的迭代对象中的数据逐个带入第一个函数作为参数,只不过兼顾了apply_async功能,将函数放入进程池
      2.返回值:
        返回func的返回值列表
      3.pool.map(fun,test)
        for i in test:
            pool.apply_async(fun,(i,))
  3.使用进程池内的进程不断的执行等待事件
    1.pool.apply()
      功能:按照顺序添加要执行的事件,执行一个再添加一个
  4.所有事件处理结束后关闭回收进程池
    1.pool.close()
      功能:关闭进程池,使其不能再加入新的事件
    2.pool.join()
      功能：阻塞等待进程池将事件都执行结束后回收进程池
      参数:无
4.进程间通信
  1.磁盘交互
    1.速度慢
    2.数据不安全
  2.套接字
  3.管道
    1.在内存中开辟一个管道空间,对多个进程可见,在通信形式上形成一种约束
    2.multiprocessing  ---》 Pipe 函数
    3.fd1,fd2=Pipe(duplex=True)
      1.功能:创建一个管道 
      2.参数:
        1.duplex默认为True表示管道为双向管道
        2.如果设置为False则表示管道为单向管道
      3.返回值:
        1.返回两个管道流对象,分别表示管道的两端
        2.如果参数为True(默认两个对象均可发送接收)
        3.如果为False时则第一个对象只能收,第二个对象只能发
    4.向管道发送数据使用send()函数,从管道接受数据使用recv()函数
      1.fd1.recv()
        1.功能:接受消息,每次一条
        2.参数:无
        3.返回值:接收到的消息
        4.管道内没有消息会阻塞
      2.fd2.send(data)
        1.可以发送字符串数字列表等多种类型数据
        2.没有接收端会引发异常
  4.消息队列
    1.multiprocessing  --- 》 Queue  
    2.在内存中开辟一个队列模型，用来存放消息。任何拥有队列对象的进程都可以进行消息的存放和取出
    3.q=Queue(maxsize = 0)
      1.功能:创建一个消息队列对象
      2.参数:
        1.maxsize 默认为0
          表示消息队列可以存放的消息由系统自动分配的空间而定
        2.>0 正整数 表示队列中最多存放多少条消息
      3.返回值:消息队列对象
    4.q.put(obj, block=True, timeout=None)
      1.向消息队列中存放一条消息,当消息队列满的时候,会阻塞
      2.当消息队列满的时候,且设置了超时时间,会引发Full异常
      3.存放的消息类型可以是数字,列表,字符串等
    5.q.full()
      判断队列是否为满,如果满则返回True否则返回False
    6.q.qsize()
      查看当前队列中消息数量
    7.q.get(block=True, timeout=None)
      1.获取消息,每次获取一条,
      2.当消息队列为空,且设置超时时间时则引发Empty异常
      3.当消息队列为空,会阻塞
    8.q.empty()
      消息队列为空则返回True不为空返回False
    9.q.close()
      关闭队列
    10.put/get 中block参数和timeout参数
      1.block默认为True表示两个函数都是阻塞函数
        如果设置为False则表示不阻塞
      2.timeout当block设置为True的时候表示超时等待时间
  5.共享内存
    1.在内存中开辟一段空间存储数据,对多个进程可见,每次存储的内容会覆盖上次的内容,由于对内存格式化较少,故存取速度快效率高
    2.from multiprocessing import Value,Array
    3.obj = Value(typecode_or_type,obj)
      1.功能:开辟共享内存空间
      2.参数:
        1.ctype  要转变的c的类型
        2.obj    要写入共享内存的初始值
    4.obj.value属性为获取共享内存中的值 
    5.obj = Array(ctype,obj)
      1.功能:开辟共享内存空间
      2.参数:
        1.要转换的c的类型
        2.obj:
          1.放入共享内存中的数据,是一个列表,要求列表中的数据为相同类型数据
          2.如果obj传入一个正数，则表示在共享内存中开辟一个 多大的空间，空间中可以存放的数值类型由ctype确定
      3.返回值:
        返回一个可迭代对象通过for循环取值，可以进行修改
  6.管道,消息队列,共享内存比较
    0.          管道         消息队列       共享内存 
    1.开辟空间  内存中       内存中           内存中
    2.读写方式  可双向/单向   先进先出        操作覆盖内存
    3.效率      一般          一般            较快
    4.应用     多用于亲缘进程 方便灵活广泛     较复杂
    5.是否需要  不需要        不需要           需要
      同步互斥
  7.信号
    1.一个进程向另一个进程通过信号传递某种信息
    2.kill -l  查看系统信号
    3.kill -signame PID 
      1.给进程号PID的进程发送signame信号
    3.信号名称:系统定义     
    4.含义:系统定义     
    5.默认处理方法:系统定义,信号给接受进程带来的行为
      1.终止 
      2.暂停 
      3.忽略
    6.重要信号
      1.SIGINT
      2.SIGQUIT
      3.SIGKILL
      4.SIGALRM
      5.SIGSTOP
      6.SIGTSTP
      7.SIGCHLD
    7.发送信号：
      1.os.kill(pid,sig)
        1.功能:向一个进程发送一个信号
        2.参数:
          1.pid:要发送进程的PID号
          2.sig:要发送的信号
      2.signal.alarm(sec) 
        1.功能:给自己发送一个时钟信号(SIGALRM)
        2.参数:sec:秒数 表示在相应的秒数后发送时钟信号
      3.信号是唯一的一种异步的进程间通信方式
      4.信号的发送不会影响进程的持续执行
      5.alarm函数在一个进程中如果使用多次,则后面的时钟时间会覆盖前面的时间
    8.信号的处理：
      1.signal.pause() 
        阻塞等待一个信号的发生
      2.signal.signal(signum,handler)
        1.功能:处理信号
        2.参数:
          1.signum:表示可以处理的信号
          2.handler:信号的处理方法
            1.默认处理方式:SIG_DFL
            2.忽略信号    :SIG_IGN
            3.自定义的方式:function
              1.自定义函数必须有两个参数
                1.第一个参数为接收到的信号
                2.第二个参数为一个信号对象
      3.signal函数也是一个异步处理信号函数
      4.SIGSTOP和SIGKILL不能被signal函数处理
      5.僵尸进程的信号处理方案
        父进程中signal(SIGCHLD,SIG_IGN)
  8.信号量
    1.给定一定的信号数量,对多个进程可见,并且多个进程均可操作,进程根据信号量的多少,可以有不同的行为
    2.multiprocessing.Semaphore()
    3.sem=Semaphore(num)
      1.功能:定义信号量
      2.参数:num:给定信号量的初始个数
      3.返回值:信号量对象
    4.sem.acquire()
      将信号量减一
    5.sem.release()
      将信号量加一
5.cookie
  multiprocessing.currrent_process()
  获取当前的进程对象
day33 2018.5.17

1.同步和互斥
  1.临界资源:对多个进程或者线程都可见的资源,容易产生争夺,我们将这类资源称为临界资源
  2.临界区:对临界资源进行操作的代码区域称之为临界区
  3.解决资源争夺:同步或者互斥
    1.同步:
      同步是一种合作关系,为完成某种任务而建立的多个进程或者线程之间的协调调用,次序等待,传递消息告知资源占用情况,这种协调可能是由于阻塞达成的
    2.互斥:
      互斥是一种制约关系，当一个进程或者线程进入到临界区后会进行加锁操作,此时其他进程(线程)无法进入临界区,只有当该进程(线程)使用后进行解锁,其他人才可以使用,这种技术往往是通过阻塞或是加锁完成
2.Event事件
  1.创建事件对象
    e = Event()
  2.提供事件阻塞
    e.wait([timeout])
  3.对事件对象进行设置,此时e.wait判断如果事件被set则结束阻塞
    e.set()
  4.清除对该事件对象的set
    e.clear()
  5.检测事件对象,如果被设置则返回True否则返回false
    e.is_set()
3.lock
  1.进程间同步互斥方法
  2.from multiprocessing import Lock
  2.创建进程锁对象
    lock = Lock()
  3.给临界区上锁
    lock.acquire()  
  4.给临界区解锁
    lock.release()  
  5.具体实现上acquire()为一个条件阻塞函数,当有任意一个进程先进行了acquire操作后,其他进程再企图进行acquire操作时就会阻塞,直到lock对象被release后其他进程才可进行下次acquire操作
  6.实现加锁 解锁
    with lock
4.线程:
  1.线程也可以使用计算机的多核资源,也是多任务编程方式之一,是计算机核心分配的最小单位
  2.线程又称为轻量级的进程,在创建和删除时消耗计算机资源少
  3.一个进程中可以包含多个线程,这所有线程共享进程的计算机资源(空间,全局变量,分配的内存等)
  4.多个线程因为共享进程的资源所以在通信上往往采用全局变量的方法
  5.线程也有自己特有的资源,比如TID,指令集等
5.创建线程 
  1.import threading 
  2.创建线程函数 
    1.t=threading.Tread(target=None,name=None,args=(), kwargs=None)
      1.功能:创建线程 
      2.参数:
          1.target 线程函数 
          2.args   以元组方式给线程函数传参
          3.kwargs 以字典方式给线程函数传参
          4.name   线程名称(默认Thread-1)
      3.返回值:返回线程对象
  3.线程属性和方法
    1.t.start()     启动一个线程
    2.t.is_alive()  查看一个线程的状态
    3.t.name        查看线程的名称
    4.t.join([sec]) 阻塞等待回收线程
    5.threading.currentThread() 得到线程对象
    6.threading.currentThread().getName()获取线程名称
    7.t.daemon=True 主线程执行结束其他线程也会结束
    8.t.setDaemon(True)
    9.t.isDaemon() 返回True或是False
    10.t.setName(name) 为线程设置名称 任意均可
6.线程的通信
  1.全局变量进行通信
  2.线程间的同步和互斥
    1.线程事件 Event
      1.e = threading.Event() 创建事件对象
      2.e.wait([timeout]) 
      3.e.set()  将e变为设置的状态
      4.e.clear()  将e变为未设置的状态
    2.线程锁 Lock
      1.lock = threading.Lock()  创建锁对象
      2.lock.acquire()   上锁
      3.lock.release()   解锁
    3.条件变量 Condition 
      1.创建条件变量对象
        con=threading.Condition()
      2.加锁
        con.acquire()
      3.解锁
        con.release()
      4.加锁时操作,先解锁,再让线程等待通知的阻塞状态
        con.wait()
      5.发送通知,线程接收到后,结束wait阻塞,执行acquire加锁操作
        con.notify()
7.多进程和多线程的区别和联系
  1.多进程和多线程都是多任务编程方式,都可以使用计算机多核
  2.进程的创建要比线程消耗更多的资源
  3.进程空间独立数据更安全,有专门的进程间通信方式进行交互
  4.一个进程包含多个线程,所以线程共享进程资源
  5.线程没有专门的通信方法,依赖全局变量进行通信,往往需要使用同步互斥机制,防止产生资源的争夺
  7.适用场景
    1.需要创建较多的并发,任务较简单,线程较合适.
    2.程序间数据资源使用重叠较多,要考虑线程锁是否需要更复杂的逻辑.
    3.多个任务并无什么关联性,不宜用多线程
    4.Python不适用于计算密集型并发
8.创建自己的线程类
  1.自定义类 继承于 原有线程类 Thread
  2.复写原有的run方法 
  3.创建线程对象调用start 的时候会自动执行run
9.作业：
  售票员和司机的故事
  1.创建父子进程，分别表示司机和售票员
  2.当售票员捕捉到 SIGINT信号时 给司机发送SIGUSR1信号，    司机打印“老司机开车了”
  当售票员捕捉到 SIGQUIT信号时 给司机发送SIGUSR2信号， 司机打印“系好安全带，小心甩出去”
  当司机捕捉到 SIGTSTP信号时 给售票员发送SIGUSR1信号， 售票员打印“到站了，下车吧”
  3.到站后 售票员先下车（子进程先退出），然后司机下车
day34 2018.5.18

1.并发与并行
  1.并发
    1.同时处理多个请求,但是内核采用轮询时间片的方式逐个访问,某一时间点实际只处理一个任务
    2.IO多路复用,协程,循环服务器,单线程
  2.并行
    1.使用多个内核,同时使用多个任务
    2.多进程,多线程
2.threadpool 线程池 第三方模块
3.GIL(全局解释器锁)
  1.python-->支持多线程-->同步和互斥-->加锁-->超级锁-->解释器在同一时刻只能解释一个线程,大量python库为了省事依赖于这种机制-->python多线程效率低
  2.GIL即为从python解释器由于上锁导致同一时刻只能解释一个线程的问题
  3.解决方案:
    1.不使用线程转而使用进程
    2.不使用c作为解释器java,c#都可以做python解释器
  4.IO密集型
    1.程序中进行了大量IO操作,只有少量的CPU操作
    2.在内存中进行了数据的交换的操作都可以认为是IO操作
    3.特点:速度较慢,使用cpu不高           
  5.cpu密集型（计算密集型）：
    1.大量的程序都在进行运算操作
    2.特点:cup占有率高
  6.多线程的工作效率和单线程几乎相近,而多进程要比前两者有明显的效率提升
  7.python线程适用于高用时的IO操作,网路IO,不适合CPU密集型程序
4.设计模式
  1.设计模式代表了一种最佳实践,是被开发人员长期开发总结,用来解决某一类问题的思路方法,这些方法保证了代码的效率也易于理解。
  2.共三种类型23种
  3.生产者消费者模式为例
    1.控制数据资源数量
    2.降低耦合度
5.总结 
  1.进程和线程的区别
  2.会创建使用线程 threading
  3.掌握基本的线程间同步互斥编程方法
  4.知道什么是GIL
  5.了解设计模式的概念
day34 2018.5.18

1.服务器模型
  1.硬件服务器:主机 集群  
  2.软件服务器:网络服务器，在后端提供网络功能,逻辑处理,数据处理的程序集合及架构 
  3.服务器架构   
    1.c/s(客户端服务器架构)    
    2.b/s(浏览器服务器架构)   
    3.服务器的组织形式
  4.服务器追求:
    1.处理速度更快
    2.数据更安全
    3.并发量更大
    4.硬件方面:
      1.更高配置
      2.更多主机
      3.集成
      4.分布
    5.软件方面
      1.程序占有更少资源
      2.更流畅的运行
      3.处理更多的并发
  5.基本的服务器模型
    1.循环模型
      1.单线程程序,循环接收连接或请求,然后处理,处理后继续循环
      2.缺点:不能同时处理多个客户端的并行,不允许某个客户端长期占用服务器资源
      3.结构较简单,适用于UDP程序,要求处理请求可以很快完成
    3.IO多路复用模型
      1.通过同时监控多个IO来达到IO并发的目的
      2.缺点:单线程,不能长期阻塞,不适合处理大量CPU占用高的程序
      3.开销小,较适合IO密集型的服务端程序
    3.并行模型
      1.每有一个客户端连接处理就创建一个进程或线程处理客户端的请求,而主进程/主线程则可以继续接收其他客户端的连接
      2.缺点:资源消耗较大
      3.适用于客户端长期占有服务器的情况
2.基于fork的多进程并发
  1.创建套接字,绑定,监听
  2.接收客户端连接请求,创建新的进程
  3.主进程继续接收下一个客户端连接请求,子进程处理客户端事件
  4.有客户端断开则关闭响应的子进程
  5.代码实现 必须会
3.ftp文件服务器
  1.获取文件列表 
  2.能够下载文件
  3.能够上传文件
4.cookie
  1.os.listdir(path):
    获取指定目录下所有文件列表
  2.os.path.isfile(filename):
    判断一个文件是否为普通文件
day35 2018.5.21

1.多线程并发
  1.相对于多进程并发特点
    1.劣势
      1.可能需要同步和互斥机制
      2.受到GIL影响
    2.优势
      只需要较少的系统资源
  2.实现
    1.threading模块
    2.步骤
      1.创建套接字
      2.准备接受客户端连接
      3.每当有一个客户端连接进来就创建一个新线程
      4.客户端退出后结束相应线程,关闭客户端套接字
2.基于多线程的httpserver
  1.思路
    1.每有一个客户端就有一个线程为其服务
    2.httpserver的功能(解析请求和处理响应)封装成类
    3.所有的静态页面收集到一个文件夹
    4.处理方法放在一个文件夹
  2.技术实现
    1.并发
      多线程
    2.类
      1.初始化
        将socket变为属性,并且增加一系列其他属性
      2.服务器启动方法
        接受客户端请求,创建新的线程
      3.客户端处理函数       
3.cookie
  1.sys.path
  2.__import__()
    参数为一个目录,等同于import导入
4.使用集成模块完成网络并发
  1.socketserver模块
  2.进程tcp并发
  3.进程udp并发
  4.线程tcp并发
  5.线程udp并发
  6.'DatagramRequestHandler',
    'ForkingMixIn',
    'ForkingTCPServer',
    'ForkingUDPServer',
    'StreamRequestHandler',
    'TCPServer',
    'ThreadingMixIn',
    'ThreadingTCPServer',
    'ThreadingUDPServer',
    'UDPServer',
    三部分 
     多进程/多线程       TCP/UDP      streamhandler/datagramhandler
     ForkingMixIn      TCPServer     StreamRequestHandler
     ThreadingMixIn    UDPServer     DatagramRequestHandler

    'ThreadingTCPServer' = ThreadingMixIn  +  TCPServer
    'ThreadingUDPServer' = ThreadingMixIn  +  UDPServer
    'ForkingTCPServer',  = ForkingMixIn    +  TCPServer
    'ForkingUDPServer',  = ForkingMixIn    +  UDPServer 
