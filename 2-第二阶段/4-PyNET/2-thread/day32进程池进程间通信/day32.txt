day32 2018.5.16

1.创建自己的进程类
  1.继承Process类以获取原有的属性
  2.实现自己需要的功能部分
  3.使用自己的类创建进程即可
2.多进程
  1.优点
    1.并行多个任务,提高运行效率
    2.空间独立,数据安全,创建方便
  2.缺点
    进程创建的过程中消耗较多的计算机资源
  3.在需要频繁的创建和删除较多进程的情况下，资源消耗过多，不适宜使用多进程完成任务
3.进程池
  from multiprocessing import pool
  1.创建进程池,在池内放入合适数量的进程
    1.Pool()
      1.功能:创建进程池
      2.参数:processes:进程池中进程的数量
      3.返回:得到进程池对象
  2.将事件加入进程池的等待队列
    1.pool.apply_async() 
      1.功能:以异步的方式将要执行的事件放入进程池
      2.参数:
        1.func:要执行的函数
        2.args:给函数按位置传参 元组
        3.kwds:给函数按照键值传参 字典
      3.返回值:
        返回事件执行后的返回值对象,可以通过调用get()函数获取事件函数return的内容
    2.pool.map(func, iterable)
      1.功能:
        类似于内建函数map将第二个参数的迭代对象中的数据逐个带入第一个函数作为参数,只不过兼顾了apply_async功能,将函数放入进程池
      2.返回值:
        返回func的返回值列表
      3.pool.map(fun,test)
        for i in test:
            pool.apply_async(fun,(i,))
  3.使用进程池内的进程不断的执行等待事件
    1.pool.apply()
      功能:按照顺序添加要执行的事件,执行一个再添加一个
  4.所有事件处理结束后关闭回收进程池
    1.pool.close()
      功能:关闭进程池,使其不能再加入新的事件
    2.pool.join()
      功能：阻塞等待进程池将事件都执行结束后回收进程池
      参数:无
4.进程间通信
  1.磁盘交互
    1.速度慢
    2.数据不安全
  2.套接字
  3.管道
    1.在内存中开辟一个管道空间,对多个进程可见,在通信形式上形成一种约束
    2.multiprocessing  ---》 Pipe 函数
    3.fd1,fd2=Pipe(duplex=True)
      1.功能:创建一个管道 
      2.参数:
        1.duplex默认为True表示管道为双向管道
        2.如果设置为False则表示管道为单向管道
      3.返回值:
        1.返回两个管道流对象,分别表示管道的两端
        2.如果参数为True(默认两个对象均可发送接收)
        3.如果为False时则第一个对象只能收,第二个对象只能发
    4.向管道发送数据使用send()函数,从管道接受数据使用recv()函数
      1.fd1.recv()
        1.功能:接受消息,每次一条
        2.参数:无
        3.返回值:接收到的消息
        4.管道内没有消息会阻塞
      2.fd2.send(data)
        1.可以发送字符串数字列表等多种类型数据
        2.没有接收端会引发异常
  4.消息队列
    1.multiprocessing  --- 》 Queue  
    2.在内存中开辟一个队列模型，用来存放消息。任何拥有队列对象的进程都可以进行消息的存放和取出
    3.q=Queue(maxsize = 0)
      1.功能:创建一个消息队列对象
      2.参数:
        1.maxsize 默认为0
          表示消息队列可以存放的消息由系统自动分配的空间而定
        2.>0 正整数 表示队列中最多存放多少条消息
      3.返回值:消息队列对象
    4.q.put(obj, block=True, timeout=None)
      1.向消息队列中存放一条消息,当消息队列满的时候,会阻塞
      2.当消息队列满的时候,且设置了超时时间,会引发Full异常
      3.存放的消息类型可以是数字,列表,字符串等
    5.q.full()
      判断队列是否为满,如果满则返回True否则返回False
    6.q.qsize()
      查看当前队列中消息数量
    7.q.get(block=True, timeout=None)
      1.获取消息,每次获取一条,
      2.当消息队列为空,且设置超时时间时则引发Empty异常
      3.当消息队列为空,会阻塞
    8.q.empty()
      消息队列为空则返回True不为空返回False
    9.q.close()
      关闭队列
    10.put/get 中block参数和timeout参数
      1.block默认为True表示两个函数都是阻塞函数
        如果设置为False则表示不阻塞
      2.timeout当block设置为True的时候表示超时等待时间
  5.共享内存
    1.在内存中开辟一段空间存储数据,对多个进程可见,每次存储的内容会覆盖上次的内容,由于对内存格式化较少,故存取速度快效率高
    2.from multiprocessing import Value,Array
    3.obj = Value(typecode_or_type,obj)
      1.功能:开辟共享内存空间
      2.参数:
        1.ctype  要转变的c的类型
        2.obj    要写入共享内存的初始值
    4.obj.value属性为获取共享内存中的值 
    5.obj = Array(ctype,obj)
      1.功能:开辟共享内存空间
      2.参数:
        1.要转换的c的类型
        2.obj:
          1.放入共享内存中的数据,是一个列表,要求列表中的数据为相同类型数据
          2.如果obj传入一个正数，则表示在共享内存中开辟一个 多大的空间，空间中可以存放的数值类型由ctype确定
      3.返回值:
        返回一个可迭代对象通过for循环取值，可以进行修改
  6.管道,消息队列,共享内存比较
    0.          管道         消息队列       共享内存 
    1.开辟空间  内存中       内存中           内存中
    2.读写方式  可双向/单向   先进先出        操作覆盖内存
    3.效率      一般          一般            较快
    4.应用     多用于亲缘进程 方便灵活广泛     较复杂
    5.是否需要  不需要        不需要           需要
      同步互斥
  7.信号
    1.一个进程向另一个进程通过信号传递某种信息
    2.kill -l  查看系统信号
    3.kill -signame PID 
      1.给进程号PID的进程发送signame信号
    3.信号名称:系统定义     
    4.含义:系统定义     
    5.默认处理方法:系统定义,信号给接受进程带来的行为
      1.终止 
      2.暂停 
      3.忽略
    6.重要信号
      1.SIGINT
      2.SIGQUIT
      3.SIGKILL
      4.SIGALRM
      5.SIGSTOP
      6.SIGTSTP
      7.SIGCHLD
    7.发送信号：
      1.os.kill(pid,sig)
        1.功能:向一个进程发送一个信号
        2.参数:
          1.pid:要发送进程的PID号
          2.sig:要发送的信号
      2.signal.alarm(sec) 
        1.功能:给自己发送一个时钟信号(SIGALRM)
        2.参数:sec:秒数 表示在相应的秒数后发送时钟信号
      3.信号是唯一的一种异步的进程间通信方式
      4.信号的发送不会影响进程的持续执行
      5.alarm函数在一个进程中如果使用多次,则后面的时钟时间会覆盖前面的时间
    8.信号的处理：
      1.signal.pause() 
        阻塞等待一个信号的发生
      2.signal.signal(signum,handler)
        1.功能:处理信号
        2.参数:
          1.signum:表示可以处理的信号
          2.handler:信号的处理方法
            1.默认处理方式:SIG_DFL
            2.忽略信号    :SIG_IGN
            3.自定义的方式:function
              1.自定义函数必须有两个参数
                1.第一个参数为接收到的信号
                2.第二个参数为一个信号对象
      3.signal函数也是一个异步处理信号函数
      4.SIGSTOP和SIGKILL不能被signal函数处理
      5.僵尸进程的信号处理方案
        父进程中signal(SIGCHLD,SIG_IGN)
  8.信号量
    1.给定一定的信号数量,对多个进程可见,并且多个进程均可操作,进程根据信号量的多少,可以有不同的行为
    2.multiprocessing.Semaphore()
    3.sem=Semaphore(num)
      1.功能:定义信号量
      2.参数:num:给定信号量的初始个数
      3.返回值:信号量对象
    4.sem.acquire()
      将信号量减一
    5.sem.release()
      将信号量加一
5.cookie
  multiprocessing.currrent_process()
  获取当前的进程对象


