day30 2018.5.14

1.os模块
  1.os.unlink() or os.remove()
    删除某个文件
    参数:一个路径文件
  2.os.path.exists()
    判断一个文件是否存在
    参数:一个路径文件
2.多任务编程
  1.通过应用程序利用多个计算机核心达到多任务同时执行的目的,以此来提升程序执行效率
  2.多进程,多线程
    1.进程
      1.程序在计算机中一次执行的过程
      2.是一个动态的过程,占有CPU内存的计算机资源,有一定的生命周期
    2.程序:
      1.是一个静态的描述,不占有计算机资源
      2.同一个程序,每次执行都是不同的进程.因为分配的计算机资源不同
  3.进程的创建流程
    1.用户空间运行程序发起进程创建申请
    2.调用操作系统内核借口创建进程
    3.分配计算机资源,确定进程状态
    4.将新的进程提供给用户使用
  4.多个进程如何占用CPU
    1.一个内核同一时刻只能运行同一任务
    2.多个进程对内核资源进行争夺,操作系统决定
    3.占有计算机核心的进程我们称该进程占有CPU的时间片
  5.进程有哪些信息,如何保存
    1.pcb(进程控制块):
      在linux和UNIX系统中进程创建后,会在内存开辟一块空间,存放进程的相关信息,称为pcb
      查看进程信息 ps -aux
      1.信息:用户 PID 占有内存 优先级
        1.PID:在操作系统中,进程的唯一标识,是大于0的整数,有系统自动分配
  6.进程特征
    1.进程是操作系统资源分配的最小单位
    2.每个进程单独占有4G的虚拟内存空间
    3.进程之间相互独立,运行不受影响
  7.进程的状态
    1.三态
      1.就绪态
        进程具备运行条件,等待系统分配处理器运行
      2.运行(执行)态
        进程占有CPU处于运行的状态
      3.等待(阻塞,睡眠)态
        进程暂时不具备运行的条件,需要阻塞等待
    2.五态 
      1.新建
        创建一个进程获取资源,运行一个程序或在程序中创建新的进程
      2.就绪
      3.执行
      4.等待/阻塞
      5.终止
        进程执行结束,资源回收过程
    3.ps -aux -->STAT表示进程状态
      1.D:等待态(不可中断等待)
      2.S:等待态(可中断等待)
      3.T:等待态(暂停)
      4.R:运行态
      5.Z:僵尸态
      6.+:前台进程 (无+表示后台进程)
      7.<:高优先级
      8.N:低优先级
      9.l:有进程链接
      10.s:会话组
  8.进程优先级
    1.优先级决定一个进程的执行权限和占有资源的优先程度
    2.ps -ajx
    3.top
      1.动态查看当前运行的进程状态
      2.< >翻页 NI表示优先级
    4.优先级范围
      1.-20~19 -20最高
      2.用户程序优先级默认为0
    5.nice
      1.以指定的优先级运行程序
      2.示例:
        1.以9的优先级运行
          nice -9
        2.以-9的优先级运行
          sudo nice --9
    6.renice 
      1.改变某个进程的优先级
      2.示例
        1.改为2优先级运行
          sudo renice 2 PID号
  9.父子进程
    1.在系统中除了初始化进程,其他进程都有一个父进程,可能有多个子进程
    2.进程树pstree命令
3.os.fork()
  1.功能:创建一个新进程
  2.参数:无
  3.返回值
    1.失败返回一个负数
    2.成功
      1.返回0
        在子进程中fork的返回值
      2.正整数(子进程的PID)
        在父进程中的返回值
  4.父进程中fork之前的内容子进程同样会复制,但父子进程空间独立,fork后的修改不会影响对方
  5.父子进程在执行上互不影响,谁先执行不确定
  6.子进程虽然复制父进程的空间,但是有自己的特性,比如自己的PID,进程PCB,进程栈空间等
4.进程相关函数
  1.os.getpid()
    1.功能:获取当前进程的PID号
    2.返回值:当前进程的PID号
  2.os.getppid()
    1.功能:获取当前进程父进程的PID号
    2.返回值:当前进程父进程的PID号
  3.os._exit(status)
    1.功能:结束一个进程
    2.参数:
      1.表示进程的结束状态,是一个整数
      2.惯例传入0表示正常退出,非0表示不正常退出
  4.sys.exit([status])
    1.功能:抛出异常SystemExit,结束一个进程
    2.参数:
      1.传入一个正整数表示结束状态
      2.传入字符串,表示结束,打印字符串
5.孤儿进程 
  1.父进程先于子进程退出,此时子进程变为孤儿进程
  2.孤儿进程会被系统指定的进程'收养',该进程成为孤儿进程新的父进程
  3.在孤儿进程退出时,继父会进行处理,不会使其变为僵尸进程
6.僵尸(zombie)进程
  1.子进程先退出,但是父进程没处理子进程的退出状况,子进程就会变为僵尸进程
  2.僵尸进程会滞留PCB的部分信息在内存中,大量的僵尸进程会消耗系统资源,应避免僵尸进程的产生 
  3.避免产生
    1.父进程先退(不好控制)
    2.让父进程处理子进程的退出
      1.使用wait或waitpid函数
        1.os.wait()
          1.功能:等待子进程的退出进行处理
          2.返回值:
            1.一个二元元组
            2.第一个值为退出的子进程PID
            3.第二个值为进程退出状态为sys.exit(status)的status*5
        2.os.waitpid()
          1.功能:处理子进程的退出
          2.参数:
            1.pid:
              1.-1:表示等待任意的子进程退出
              2.>0:表示等待相应的PID号的子进程
            2.option:
              1.0:表示阻塞等待
              2.os.WNOHANG:表示非阻塞等待
          3.返回值:
            1.一个二元元组
            2.第一个值为退出的子进程PID
            3.第二个值为进程退出状态为sys.exit(status)的status*5
          4.示例:
            见waitpid.py
    3.使用信号处理
    4.创建二级子进程
      1.整体思路
        1.父进程创建子进程后等待子进程退出
        2.子进程创建二级子进程后马上退出,二级子进程成为孤儿
        3.让父进程和二级子进程处理事件
      2.示例:
        见fork.py















