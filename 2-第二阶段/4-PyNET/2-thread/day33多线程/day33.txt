day33 2018.5.17

1.同步和互斥
  1.临界资源:对多个进程或者线程都可见的资源,容易产生争夺,我们将这类资源称为临界资源
  2.临界区:对临界资源进行操作的代码区域称之为临界区
  3.解决资源争夺:同步或者互斥
    1.同步:
      同步是一种合作关系,为完成某种任务而建立的多个进程或者线程之间的协调调用,次序等待,传递消息告知资源占用情况,这种协调可能是由于阻塞达成的
    2.互斥:
      互斥是一种制约关系，当一个进程或者线程进入到临界区后会进行加锁操作,此时其他进程(线程)无法进入临界区,只有当该进程(线程)使用后进行解锁,其他人才可以使用,这种技术往往是通过阻塞或是加锁完成
2.Event事件
  1.创建事件对象
    e = Event()
  2.提供事件阻塞
    e.wait([timeout])
  3.对事件对象进行设置,此时e.wait判断如果事件被set则结束阻塞
    e.set()
  4.清除对该事件对象的set
    e.clear()
  5.检测事件对象,如果被设置则返回True否则返回false
    e.is_set()
3.lock
  1.进程间同步互斥方法
  2.from multiprocessing import Lock
  2.创建进程锁对象
    lock = Lock()
  3.给临界区上锁
    lock.acquire()  
  4.给临界区解锁
    lock.release()  
  5.具体实现上acquire()为一个条件阻塞函数,当有任意一个进程先进行了acquire操作后,其他进程再企图进行acquire操作时就会阻塞,直到lock对象被release后其他进程才可进行下次acquire操作
  6.实现加锁 解锁
    with lock
4.线程:
  1.线程也可以使用计算机的多核资源,也是多任务编程方式之一,是计算机核心分配的最小单位
  2.线程又称为轻量级的进程,在创建和删除时消耗计算机资源少
  3.一个进程中可以包含多个线程,这所有线程共享进程的计算机资源(空间,全局变量,分配的内存等)
  4.多个线程因为共享进程的资源所以在通信上往往采用全局变量的方法
  5.线程也有自己特有的资源,比如TID,指令集等
5.创建线程 
  1.import threading 
  2.创建线程函数 
    1.t=threading.Tread(target=None,name=None,args=(), kwargs=None)
      1.功能:创建线程 
      2.参数:
          1.target 线程函数 
          2.args   以元组方式给线程函数传参
          3.kwargs 以字典方式给线程函数传参
          4.name   线程名称(默认Thread-1)
      3.返回值:返回线程对象
  3.线程属性和方法
    1.t.start()     启动一个线程
    2.t.is_alive()  查看一个线程的状态
    3.t.name        查看线程的名称
    4.t.join([sec]) 阻塞等待回收线程
    5.threading.currentThread() 得到线程对象
    6.threading.currentThread().getName()获取线程名称
    7.t.daemon=True 主线程执行结束其他线程也会结束
    8.t.setDaemon(True)
    9.t.isDaemon() 返回True或是False
    10.t.setName(name) 为线程设置名称 任意均可
6.线程的通信
  1.全局变量进行通信
  2.线程间的同步和互斥
    1.线程事件 Event
      1.e = threading.Event() 创建事件对象
      2.e.wait([timeout]) 
      3.e.set()  将e变为设置的状态
      4.e.clear()  将e变为未设置的状态
    2.线程锁 Lock
      1.lock = threading.Lock()  创建锁对象
      2.lock.acquire()   上锁
      3.lock.release()   解锁
    3.条件变量 Condition 
      1.创建条件变量对象
        con=threading.Condition()
      2.加锁
        con.acquire()
      3.解锁
        con.release()
      4.加锁时操作,先解锁,再让线程等待通知的阻塞状态
        con.wait()
      5.发送通知,线程接收到后,结束wait阻塞,执行acquire加锁操作
        con.notify()
7.多进程和多线程的区别和联系
  1.多进程和多线程都是多任务编程方式,都可以使用计算机多核
  2.进程的创建要比线程消耗更多的资源
  3.进程空间独立数据更安全,有专门的进程间通信方式进行交互
  4.一个进程包含多个线程,所以线程共享进程资源
  5.线程没有专门的通信方法,依赖全局变量进行通信,往往需要使用同步互斥机制,防止产生资源的争夺
  7.适用场景
    1.需要创建较多的并发,任务较简单,线程较合适.
    2.程序间数据资源使用重叠较多,要考虑线程锁是否需要更复杂的逻辑.
    3.多个任务并无什么关联性,不宜用多线程
    4.Python不适用于计算密集型并发
8.创建自己的线程类
  1.自定义类 继承于 原有线程类 Thread
  2.复写原有的run方法 
  3.创建线程对象调用start 的时候会自动执行run
9.作业：
  售票员和司机的故事
  1.创建父子进程，分别表示司机和售票员
  2.当售票员捕捉到 SIGINT信号时 给司机发送SIGUSR1信号，    司机打印“老司机开车了”
  当售票员捕捉到 SIGQUIT信号时 给司机发送SIGUSR2信号， 司机打印“系好安全带，小心甩出去”
  当司机捕捉到 SIGTSTP信号时 给售票员发送SIGUSR1信号， 售票员打印“到站了，下车吧”
  3.到站后 售票员先下车（子进程先退出），然后司机下车
  















