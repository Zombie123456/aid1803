day08 2018.4.11
1.列表可以改变 字符串和元组不能改变
2.列表的in/not in
3.列表的索引
4.列表的索引赋值
5.列表的切片
  列表的切片赋值:
    列表[切片]=可迭代对象
  示例:
    L=[2,3,4]
    L=[0:1]=[1.1,2.2]#L=[1.1,2.2,3,4]
    L=[2,4] L=[1:1]=3#L=[2,3,4]
  注:步长不等于1时,可迭代对象能提供的数据元素一定要
  等于切下来的段数
6.del 语句:
  同于删除列表中的元素
  del 序列[整数表达式]
  del 序列[切片]
  示例:
    l=[1,2,3,4,5,6]
    del l[-1]#l=[1,2,3,4,5]
    del l[::2]#l=[2,4,6]
7.用于序列的函数:
  any(x)容器中有一个值为True返回True,否则返回False
  all(x)容器中全为为True返回True,否则返回False
  sum() 累加,元素必须全为数据类型
  len()
  max()
  min()
8.常用的列表方法:
  L.index(value [, begin[, end]])
    返回对应元素的索引下标, begin为开始索引，end为结束索引,当value不存在时触发ValueError错误
  L.insert(index, obj)
    将某个元素插放到列表中指定的位置
  L.count(x)      返回列表中元素的个数
  L.remove(x)     从列表中删除第一次出现在列表中的值
  L.copy()
    复制此列表（只复制一层，不会复制深层对象)
  L.append(x)     向列表中追加单个元素
  L.extend(lst)   向列表追加另一个列表
  L.clear()   清空列表,等同于 L[:] = []
  L.sort(reverse=False)
    将列表中的元素进行排序，默认顺序按值的小到大的顺序排列
  L.reverse()
    列表的反转，用来改变原列表的先后顺序
  L.pop([index])  删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系
9.浅拷贝shallow copy和深拷贝deep copy
  浅拷贝:
    在复制过程中,只复制一层变量,不会复制深层变量
    绑定的对象
    l=[3.1,3.2]
    l1=[1,2,l]
    l2=l1.copy()
    l[0]=3.14
    #l1=[1,2,[3.14,3.2]] l2=[1,2,[3.14,3.2]]
  深拷贝:
    import copy
    l=[3.1,3.2]
    l1=[1,2,l]
    l2=copy.deepcopy(l1)
    l[0]=3.14
    #l1=[1,2,[3.14,3.2]] l2=[1,2,[3.1,3.2]]
   1.深浅拷贝都是对源对象的复制,占用不同的内存空间
   2.不可变类型的对象,对于深浅拷贝毫无影响,最终的
   地址值和值都是相等的
   3.可变类型:
     =浅拷贝:值相等,地址相等
     copy浅拷贝:值相等,地址不相等
     deepcopy深拷贝:值相等,地址不相等
  l1=[1,2,[3.1,3.2]]
  l1[2][0]=3.14#l1=[1,2,[3.14,3.2]]
10.列表与字符串比较:
  都是序列,元素之间有先后关系
  字符串不可变,列表可变
  都是可迭代对象
11.字符串文本解析方法split和join
  s.split(sep=None):
    将字符串使用sep作为分隔符分割S字符串,返回分割后的字符串列表,不给定参数时,用空白字符作为分隔符分割
  s.join(iterable):用可迭代对象中的字符串,返回一个中间用s进行分割的字符串
  示例:
    s='beijing is capital'
    l=s.split(' ')#l=['beijing','is','capital']
    s=' '.join(l)#s='beijing is capital'
12.列表推导式list comprehension:
    [表达式 for 变量 in 可迭代对象]
    [表达式 for 变量 in 可迭代对象 if 真值表达式]
   列表推导式嵌套:
    [表达式1 for 变量1 in 可迭代对象1 if 真值表达式1
            for 变量2 in 可迭代对象2 if 真值表达式2]
